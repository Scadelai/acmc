Objetivo: Desenvolva um módulo gerador de código Assembly para uma arquitetura MIPS-like RISC, baseado em código intermediário (quadruplas). O sistema deve lidar com funções, recursão, iterações e gerenciamento eficiente de memória/registradores.

1. Entradas:
Código Intermediário: Lista de quadruplas com estrutura:
typedef struct {
    Operacao op;       // Enum: add, call, loadVar, storeVet, etc.
    Endereco end1;     // { tipo: Vazio/Const/String, valor: int/nome }
    Endereco end2;     // (operandos ou parâmetros)
    Endereco end3;
} Quadrupla;
Tabela de Símbolos: Escopos globais/locais, tipos de variáveis (int/vetor), tamanhos.

2. Saídas:
Código Assembly: Lista de instruções no formato:
struct Instrucao {
    Instrucoes op;      // Enum: ADD, LW, JAL, etc.
    Registradores rs, rt, rd; 
    int imediato;       // Valor imediato (se aplicável)
    string label;       // Label para saltos
};

3. Estruturas de Dados Essenciais:
// Gerenciamento de Escopos
struct Escopo {
    string nome;          // "global", "main", "gcd"
    int pos_mem;          // Próxima posição livre no frame
    vector<Var> variaveis;// Variáveis deste escopo
    Escopo* prox;
};

struct Var {
    string nome;
    int tipo;             // 0: int, 1: vetor
    int loc_mem;          // Endereço absoluto ou offset
    int tamanho;          // Para vetores
};

// Gerenciamento de Registradores
int reg_disponiveis[26];  // 0=livre, 1=ocupado ($t0 a $t25)
Registradores aloca_reg(); // Retorna um registrador livre

// Pilha de Chamadas
stack<Registradores> pilha_param; // Empilha registradores antes de "call"

4. Algoritmo-Chave:
Para cada quadrupla:
Chamadas de Função (call) (código em python que deverá ser convertido para C):
if quadrupla.op == CALL:
    # Empilha registradores em uso
    for reg in regs_ocupados:
        gera_instrucao("SW", reg, "$sp", 0);
        gera_instrucao("ADDI", "$sp", "$sp", 1);
    
    # Passagem de parâmetros
    while !pilha_param.empty():
        param = pilha_param.pop()
        gera_instrucao("SW", param, "$sp", 0)
        gera_instrucao("ADDI", "$sp", "$sp", 1)
    
    gera_instrucao("JAL", label=quadrupla.end1.nome)
    
    # Desempilha registradores
    for reg in reversed(regs_ocupados):
        gera_instrucao("ADDI", "$sp", "$sp", -1)
        gera_instrucao("LW", reg, "$sp", 0)

Acesso a Variáveis (loadVar/storeVar) (código em python que deverá ser convertido para C):
if quadrupla.op == LOAD_VAR:
    escopo = busca_escopo(quadrupla.end2.nome)
    var = busca_var(escopo, quadrupla.end1.nome)
    offset = var.loc_mem - (0 if escopo=="global" else 2)
    gera_instrucao("LW", reg_dest, "$fp", offset)

Recursão:
Tratada naturalmente via pilha:
    - Novo frame alocado em $sp.
    - $fp e $ra salvos no frame.
    - Parâmetros copiados do caller para callee.

Iterações (while/for) (código em python que deverá ser convertido para C):
if quadrupla.op == IFFALSO:  # Condicional de loop
    gera_label("LOOP_INICIO")
    # ... código condição ...
    gera_instrucao("BEQZ", reg_cond, "LOOP_FIM")
    # ... corpo do loop ...
    gera_instrucao("J", "LOOP_INICIO")
    gera_label("LOOP_FIM")

5. Gerenciamento de Memória:
Globais: Alocadas em endereços fixos (0-255).
Locais:
void aloca_var(Quadrupla q, Escopo* escopo) {
    if (escopo->nome == "global") {
        var.loc_mem = escopo->pos_mem;
        escopo->pos_mem += (q.op == ALLOC_MEM_VET) ? q.end3.valor : 1;
    } else {
        var.loc_mem = escopo->pos_mem;
        escopo->pos_mem += (q.op == ALLOC_MEM_VET) ? q.end3.valor : 1;
        // Frame: [0]$fp_antigo, [1]$ra, [2+] variáveis
    }
}

6. Registradores Especiais:
Registrador	Função
$fp         Frame Pointer (início do frame)
$sp         Stack Pointer (topo da pilha)
$ra         Return Address
$rf         Valor de retorno de funções
$t0-$t25    Temporários

7. Exemplo de Tradução:
Quadrupla:
(CALL, "gcd", 2, _)
→ Assembly:
SW $t0, 0($sp)   # Empilha reg. usado
ADDI $sp, $sp, 1
JAL gcd          # Salto para função
ADDI $sp, $sp, -1
LW $t0, 0($sp)   # Desempilha

8. Requisitos Não-Funcionais:
    - Eficiência: Minimizar acesso à memória.
    - Legibilidade: Gerar labels descritivas (FUNC_gcd_INICIO).
    - Extensibilidade: Facilitar adição de novas instruções.